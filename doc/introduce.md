
### 核心逻辑分析

1. **配置读取器 (`config_reader`)**:
   - 提供了读取配置文件的功能，支持获取字符串、数字、布尔值等。
   - 使用静态单例模式，通过 `config_reader::ins()` 获取实例。
   - 配置文件路径通过 `config_reader::setPath()` 设置。

2. **事件循环 (`event_loop`)**:
   - 核心组件，负责管理所有的 IO 事件和定时器事件。
   - 使用 `epoll` 实现高效的事件监听。
   - 提供了 `run_after` 和 `run_every` 方法，用于定时任务调度。

3. **TCP/UDP 通信**:
   - `tcp_server` 和 `tcp_client` 提供了 TCP 的服务端和客户端实现。
   - `udp_server` 和 `udp_client` 提供了 UDP 的服务端和客户端实现。
   - 支持多线程模式，主线程负责接受连接，工作线程池处理具体的 IO 和业务逻辑。

4. **缓冲区管理**:
   - 通过预分配不同大小的缓冲区池，优化内存使用。
   - 每个连接动态申请和释放缓冲区，避免长期占用。

5. **定时器队列 (`timer_queue`)**:
   - 使用最小堆管理定时器任务。
   - 定时器事件通过 `timerfd` 通知 `event_loop`。

### Reactor 模型解释

#### 什么是 Reactor 模型？

Reactor 模型是一种事件驱动的设计模式，广泛用于高性能网络服务器中。其核心思想是：
- **事件分离**: 将事件的检测和处理分离。
- **事件驱动**: 使用操作系统提供的多路复用机制（如 `epoll`）监听多个事件。
- **回调机制**: 当事件发生时，调用预先注册的回调函数处理事件。

#### Reactor 模型的实现

在本项目中，Reactor 模型的实现包括以下部分：
1. **事件检测**:
   - 使用 `epoll` 监听文件描述符的读写事件。
   - 所有的 IO 操作设置为非阻塞模式。

2. **事件分发**:
   - 主线程通过 `epoll_wait` 获取就绪事件。
   - 根据事件类型（如可读、可写）调用对应的回调函数。

3. **多线程支持**:
   - 主线程作为 Accepter，负责接受新连接。
   - 工作线程池中的每个线程运行一个 `event_loop`，处理分配给它的连接。

4. **定时器支持**:
   - 定时器事件通过 `timerfd` 转化为 IO 事件。
   - `event_loop` 统一管理 IO 和定时器事件。

#### 优势
- **高性能**: 使用 `epoll` 等高效的事件通知机制。
- **扩展性强**: 支持多线程，适合高并发场景。
- **灵活性**: 用户可以自定义事件处理逻辑。

